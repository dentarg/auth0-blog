---
layout: post
title: "Critical Vulnerability in JSON Web Encryption"
description: "JSON Web Encryption is vulnerable to a classic Invalid Curve Attack. Learn how this may affect you and what to do about it."
date: 2017-03-13 10:30
category: Security, Announcement
author:
  name: "Antonio Sanso"
  url: "https://twitter.com/asanso"
  avatar: "https://www.gravatar.com/avatar/56227bdd539c480cc054eaa72eb1885d?s=200"
design:
  bg_color: "#222228"
  image: https://cdn.auth0.com/blog/jwtalgos/logo.png
  image_size: "100%"
  image_bg_color: "#222228"
related:
  - 2015-12-17-json-web-token-signing-algorithms-overview
  - critical-vulnerabilities-in-json-web-token-libraries
  - ten-things-you-should-know-about-tokens-and-cookies
tags:
  - JWE
  - JSON-Web-Encryption
  - jwt
  - json-web-token-encryption
---

---

**TL;DR** If you are using [go-jose](https://github.com/square/go-jose), [node-jose](https://github.com/cisco/node-jose), [jose2go](https://github.com/dvsekhvalnov/jose2go), [Nimbus JOSE+JWT](https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home) or [jose4](https://bitbucket.org/b_c/jose4j/wiki/Home) with [ECDH-ES](https://tools.ietf.org/html/rfc7518) please update to the latest version. [RFC 7516 aka JSON Web Encryption (JWE)](https://tools.ietf.org/html/rfc7516) and software libraries implementing this specification used to suffer from a classic [Invalid Curve Attack](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.3920&rep=rep1&type=pdf). This can allow an attacker to recover the secret key of a party using JWE with [Key Agreement with Elliptic Curve Diffie-Hellman Ephemeral Static (ECDH-ES)](https://tools.ietf.org/html/rfc7518), where the sender could extract receiver’s private key.

---

## Premise

In this blog post I assume you are already knowledgeable about elliptic curves and their use in cryptography. If not [Nick Sullivan](https://twitter.com/grittygrease)'s  [A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/) or Andrea Corbellini's series [Elliptic Curve Cryptography: finite fields and discrete logarithms](andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/) are great starting points. Then if you further want to [climb the elliptic learning curve](https://moderncrypto.org/mail-archive/curves/2016/000784.html) including the related attacks you might also want to visit [https://safecurves.cr.yp.to/](https://safecurves.cr.yp.to/). Also the [DJB and Tanja talk at 31c3](https://www.youtube.com/watch?v=y_YxRUTI-xU) comes with an explanation of this very attack (see minute 43) or  [Juraj Somorovsky et al's research](web-in-security.blogspot.ch/2015/09/practical-invalid-curve-attacks.html) can become handy for learners. 

Note that this research was started and inspired by [Quan Nguyen from Google](https://research.google.com/pubs/pub45790.html) and then refined by [Antonio Sanso from Adobe](https://twitter.com/asanso).

## Introduction

JSON Web Token (JWT) is a JSON-based open standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) defined in the [OAuth specification family](https://tools.ietf.org/wg/oauth/) used for creating access tokens. The [Javascript Object Signing and Encryption (JOSE) IETF expert group](https://tools.ietf.org/wg/jose/) was then formed to formalize a set of signing and encryption methods for JWT that led to the release of  [RFC 7515 aka JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515) and [RFC 7516 aka JSON Web Encryption (JWE)](https://tools.ietf.org/html/rfc7516). In this post we are going to focus on JWE.

A typical JWE is dot separated string that contains five parts:

* The JWE Protected Header
* The JWE Encrypted Key
* The JWE Initialization Vector
* The JWE Ciphertext
* The JWE Authentication Tag

An example of a JWE taken from the [specification](https://tools.ietf.org/html/rfc7516) would look like:

```
eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGeipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDbSv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaVmqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je81860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi6UklfCpIMfIjf7iGdXKHzg.
48V1_ALb6US04U3b.5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji      SdiwkIr3ajwQzaBtQD_A.XFBoMYUZodetZdvTiFvSkQ
```

This JWE employs RSA-OAEP for key encryption and A256GCM for content encryption :

![JWE Token](https://cdn.auth0.com/blog/jwe-vulnerability/header0.png)

This is only one of the many possibilities JWE provides. A separate specification called [RFC 7518 aka JSON Web Algorithms (JWA)](https://tools.ietf.org/html/rfc7518) lists all the possible available algorithms that can be used. The one we are discussing today is the [Key Agreement with Elliptic Curve Diffie-Hellman Ephemeral Static (ECDH-ES)](https://tools.ietf.org/html/rfc7518).  This algorithm allows deriving an ephemeral shared secret ([this blog post from Neil Madden](https://neilmadden.wordpress.com/2016/05/20/ephemeral-elliptic-curve-diffie-hellman-key-agreement-in-java/) shows a concrete example on how to do ephemeral key agreement).

In this case the *JWE Protected Header* lists as well the used elliptic curve used for  the key agreement:

![JWE Decoded](https://cdn.auth0.com/blog/jwe-vulnerability/header.png)

Once the shared secret is calculated the key agreement result can be used in one of two ways: 

1. Directly as the Content Encryption Key (CEK) for the "enc" algorithm, in the Direct Key Agreement mode, or

2. As a symmetric key used to wrap the CEK with the A128KW, A192KW, or A256KW algorithms, in the Key Agreement with Key Wrapping mode.

This is out of scope for this post but as for the other algorithms the [JOSE Cookbook](https://tools.ietf.org/html/rfc7520) contains example of usage for ECDH-ES in combination with AES-GCM or AES-CBC plus HMAC.

## Observation

As highlighted by Quan during his talk at [RWC 2017](https://www.realworldcrypto.com/rwc2017):

>Decryption/Signature verification input is always under attacker’s control

As we will see thorough this post this simple observation will be enough to recover the receiver’s private key. But first we need to dig a bit into elliptic curve bits and pieces.

## Elliptic Curves

An elliptic curve is the set of solutions defined by an equation of the form: 

**y^2 = x^3 + ax + b**

Equations of this type are called *Weierstrass equations*. An elliptic curve would look like:

![Elliptic Curve](https://cdn.auth0.com/blog/jwe-vulnerability/EC.png)

**y^2 = x^3 + 4x + 20**

In order to apply the theory of elliptic curves to cryptography we need to look at elliptic curves whose points have coordinates in a finite field Fq. The same curve will then look like below over Finite Field of size 191:

![Field Size](https://cdn.auth0.com/blog/jwe-vulnerability/ECFP.png)

**y^2 = x^3 + 4x + 20 over Finite Field of size 191**

For JWE the elliptic curves in scope are the one defined in [Suite B](https://www.nsa.gov/ia/programs/suiteb_cryptography/index.shtml) and ([only recently](https://www.rfc-editor.org/rfc/rfc8037.txt)) [DJB](https://cr.yp.to/djb.html)'s curve.
Between those, the curve that so far has reached the higher amount of usage is the famous P-256. 

Time to open [Sage](www.sagemath.org/). Let's define P-256:

![P-256](https://cdn.auth0.com/blog/jwe-vulnerability/p256.png)

The order of the curve is a really huge number hence there isn't much an attacker can do with this curve (if the software implements ECDH correctly) in order to guess the private key used in the agreement. This brings us to the next section:

## The Attack

The attack described here is really the classical [Invalid Curve Attack](citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.3920&rep=rep1&type=pdf). The attack is simple and powerful and takes advantage from the mere fact that Weierstrass's formula for scalar multiplication does not take in consideration the coefficient b of the curve equation: 

**y^2 = ax^3 + ax + b**.

The original's P-256 equation is:

![P-256](https://cdn.auth0.com/blog/jwe-vulnerability/p256.png)

As we mention above, the order of this curve is really big. So we need now to find a more convenient curve for the attacker. Easy peasy with Sage:

![Sage](https://cdn.auth0.com/blog/jwe-vulnerability/lift.png)

As you can see from the image above we just found a nicer curve (from the attacker point of view) that has an order with many small factors. Then we found a point P on the curve that has a really small order (2447 in this example).

Now we can build malicious JWEs (see the **Demo Time section** below) and extract the value of the secret key modulo 2447 with complexity in constant time.

A crucial part for the attack to succeed is to have the victim to repeat his own contribution to the resulting shared key. In other words this means that the victim should have his private key to be the same for each key agreement. Conveniently enough this is how the [Key Agreement with Elliptic Curve Diffie-Hellman Ephemeral Static (ECDH-ES)](https://tools.ietf.org/html/rfc7518) works. Indeed ES stands for Ephemeral-Static were Static is the contribution of the victim!

At this stage we can repeat these operations (find a new curve, craft malicious JWEs, recover the secret key modulo the small order) many many times and collecting information about the secret key modulo many many small orders. 

And finally [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem) for the win!

At the end of the day the issue here is that the specification and consequently all the libraries I checked missed validating that the received public key (contained in the JWE Protected Header is on the curve), You can see the Vulnerable Libraries section below to check how the various libraries fixed the issue.

Again you can find details of the attack in the [original paper](citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.3920&rep=rep1&type=pdf).

## Demo Time

**[INSTANT DEMO CLICK HERE](https://afternoon-fortress-81941.herokuapp.com/)**

![Demo](https://cdn.auth0.com/blog/jwe-vulnerability/attacker.png)

### Explanation

In order to show how the attack would work in practice I set up a live demo in Heroku. In [https://obscure-everglades-31759.herokuapp.com/](https://obscure-everglades-31759.herokuapp.com/) is up and running one Node.js server app that will act as a victim in this case. The assumption is this: in order to communicate with this web application you need to encrypt a token using the [Key Agreement with Elliptic Curve Diffie-Hellman Ephemeral Static (ECDH-ES)](https://tools.ietf.org/html/rfc7518). The static public key from the server needed for the key agreement is in [https://obscure-everglades-31759.herokuapp.com/ecdh-es-public.json](https://obscure-everglades-31759.herokuapp.com/ecdh-es-public.json):

![Demo explanation](https://cdn.auth0.com/blog/jwe-vulnerability/ecdh.png)

An application that wants to POST data to this server needs first to do a key agreement using the server's public key above and then encrypt the payload using the derived shared key using the JWE format. Once the JWE is in place this can be posted to [https://obscure-everglades-31759.herokuapp.com/secret](https://obscure-everglades-31759.herokuapp.com/secret). The web app will respond with a response status 200 if all went well (namely if it can decrypt the payload content) and with a response status 400 if for some reason the received token is missing or invalid. This will act as an oracle for any potential attacker in the way shown in the previous The Attack section.

I set up an attacker application in [https://afternoon-fortress-81941.herokuapp.com/](https://afternoon-fortress-81941.herokuapp.com/).

You can visit it and click the 'Recover Key' button and observe how the attacker is able to recover the secret key from the server piece by piece. Note that this is only a demo application so the recovered secret key is really small in order to reduce the waiting time. In practice the secret key will be significantly larger (hence it will take a bit more to recover the key).

In case you experience problem with the live demo, or simply if  want to see the code under the hood, you can find the demo code in Github:

* [https://github.com/asanso/jwe-receiver](https://github.com/asanso/jwe-receiver) contains the code of the vulnerable server. 
* [https://github.com/asanso/jwe-sender](https://github.com/asanso/jwe-sender) contains the code of the attacker.

## Vulnerable Libraries

Here you can find a list of libraries that were vulnerable to this particular attack so far:

* [node-jose](https://github.com/cisco/node-jose) v0.9.3 include the fixes necessary, which was [published few weeks ago](https://github.com/cisco/node-jose/blob/master/CHANGELOG.md). Here the [Gist](https://gist.github.com/asanso/fa25685348051ef6a28d49aa0f27a4ae) of the original proof of concept.*
* [jose2go](https://github.com/dvsekhvalnov/jose2go)'s fix landed in [version 1.3](https://groups.google.com/forum/). 
* [Nimbus JOSE+JWT](https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home) pushed out a fixed artifact to Maven central as v4.34.2. Here the [Gist](https://gist.github.com/asanso/5b8cabb862e6f730e00a97d8565dc325) of the original proof of concept.**
* [jose4](https://bitbucket.org/b_c/jose4j/wiki/Home) now comes with a [fix](https://bitbucket.org/b_c/jose4j/commits/0517896170af8d5c057407c70a7b08dae454829e) for this problem since v0.5.5. Here the [Gist](https://gist.github.com/asanso/350e3ce993e44d0509c6023aa77fc6af) of the original proof of concept.**
* [go-jose](https://github.com/square/go-jose) (this is the original library found vulnerable by [Quan Nguyen](https://research.google.com/pubs/pub45790.html))

Some of the libraries were implemented in a programming language that already protects against this attack checking that the result of the scalar multiplication is on the curve:

\* Latest version of Node.js appears to be immune to this attack. It was still possible to be vulnerable when using browsers without web crypto support.

** Affected was the default Java SUN JCA provider that comes with Java prior to version 1.8.0_51. Later Java versions and the BouncyCastle JCA provider do not seem to be affected.  

## Improving the JWE Standard

I reported this issue to the JOSE working group via [mail to the appropriate mailing list](https://www.ietf.org/mail-archive/web/jose/current/msg05612.html). We all seem to agree that an errata where the problem is listed is at least welcomed. This post is a direct attempt to raise awareness about this specific problem.

## Acknowledgement

The author would like to thanks the maintainers of [go-jose](https://github.com/square/go-jose), [node-jose](https://github.com/cisco/node-jose),[jose2go](https://github.com/dvsekhvalnov/jose2go), [Nimbus JOSE+JWT](https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home) and [jose4](https://bitbucket.org/b_c/jose4j/wiki/Home) for the responsiveness on fixing the issue. [Francesco Mari](https://twitter.com/francescomari) for helping out with the development of the demo application. Tommaso Teofili and Simone Tripodi for troubleshooting. Finally as mentioned above I would like to thank [Quan Nguyen from Google](https://research.google.com/pubs/pub45790.html), indeed this research could not be possible without his initial incipit.

That's all folks. For more crypto goodies, follow me on [Twitter](https://twitter.com/asanso/).

<div class="alert alert-info">
<strong>About Antonio Sanso:</strong><br />
Antonio works as Senior Software Engineer at Adobe Research Switzerland where he is part of the Adobe Experience Manager security team. Antonio is co-author of "OAuth 2 in Action" book. He found vulnerabilities in popular software such as OpenSSL, Google Chrome, Apple Safari and is included in the Google, Facebook, Microsoft, Paypal and Github security hall of fame. He is an avid open source contributor, being the Vice President (chair) for Apache Oltu and PMC member for Apache Sling. His working interests span from web application security to cryptography. Antonio is also the author of more than a dozen computer security patents and applied cryptography academic papers. He holds an MSc in Computer Science.
</div> 